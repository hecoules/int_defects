function [ contDepFlags ] = int_defects_contour_independence_check( kCell, noContourRequests, contourType, varargin )
%int_defects_contour_independence_check.m
%Harry Coules 2015
%   04/2019 - Modified to enable J-integral contour-dependence checking.
%
%DESCRIPTION
%This function is used to check the contour-independence of Mode I stress
%intensity factors (or other contour integral quantities) generated by a
%finite element analysis using Abaqus/Standard.
%
%INPUT ARGUMENTS
%   kCell - A 6-by-n cell array containing SIF data read from the .dat of
%      an Abaqus analysis by read_dat_contour_integral
%   noContourRequests - Number of contour integral output requests for which
%       results exist in the array kCell.
%   contourType - String indicating the type of contour integral data.
%       Should be either 'k', 't' or 'j'.
%   OPTIONAL
%   tol - The tolerance for the relative difference between the last and
%       last-but-one contours.
%
%OUTPUT ARGUMENTS
%   contDepFlags = a logical of length n specifying whether each contour
%       integral result shows path-dependence.
%
%% Check input arguments
%Check contour type
if ~any(strcmpi(contourType,{'k','j','t'}))
    error('Invalid contour integral type specified.');
end

%Optional input argument
if isempty(varargin)
    warning('No contour-dependence tolerance specified in input arguments. Assuming tol = 0.01.')
    tol = 0.01;
elseif length(varargin)==1
    tol = varargin{1};
else
    error('Too many input arguments.')
end

%% Perform contour-independence checking
%Determine the range of results to check. We only check the last cell (for
%single-output models) or the last and last-but-one cells (for models with
%two contour integral output requests), i.e. results from the last model
%increment.
if noContourRequests == 1
    cellRange = size(kCell,2);
elseif noContourRequests == 2
    cellRange = [size(kCell,2)-1,size(kCell,2)];
else
    error('Unexpected number of contour integral output requests (noContourRequests).');
end

%Check contour integral results
contDepFlags = [];
for k1 = 1:length(cellRange)
    k2 = cellRange(k1);
    
    kCrack = kCell{2,k2};
    noContours = size(kCrack,1);
    if noContours < 3
        error('Not enough contours to evaluate contour-dependence of the result.')
    end
    
    %Evaluate the error between the last and last-but-one contours and the
    %last-but-one and the last-but two.
    err1 = abs(1-(kCrack(end,:)./kCrack((end-1),:)));
    err2 = abs(1-(kCrack((end-1),:)./kCrack((end-2),:)));
    
    %Tolerance of tol on last and 5*tol on last-but-one
    outOfTol1 = err1 > tol;
    outOfTol2 = err2 > 5*tol;
    
    %For J-integral, the results should always be positive
    if strcmpi(contourType,'j')
        outOfTol3 = kCrack(end,:)<0;
    else
        outOfTol3 = zeros(1,length(kCrack(end,:)));
    end
    
    %To trigger a contour-dependence flag, >5% of the contour locations on
    %the crack front must show contour-dependence
    if (sum(outOfTol1)/length(err1)) >= 0.1                    %The tolerance of tol on last
        contDepFlags(k1) = true;
    elseif (sum(outOfTol2)/length(err2)) >= 0.1                %The tolerance of 5*tol on last-but-one
        contDepFlags(k1) = true;
    elseif (sum(outOfTol3)/length(kCrack(end,:))) >= 0.1       %J-integral results must be positive
        contDepFlags(k1) = true;
    else
        contDepFlags(k1) = false;
    end
end

end